#测试的目的：
(1)	寻找软件的缺陷
(2)	跟踪修正软件缺陷
(3)	验证修正的软件缺陷
#测试的原则：
(1)	尽早进行软件测试，早期发现和报告软件缺陷
(2)	全程测试，测试过程贯穿于整个项目的生命周期
(3)	测试独立与开发，开发人员不能测试自己的软件
(4)	软件的缺陷驱动开发（基本代码完成后愈加明显）

#插播一个知识点：缺陷驱动：在软件开发过程中遇到了无法解决或者难于解决的问题，才去考虑选择能够解决问题的新技术和方法。否则保持不变。

##测试的局限性：
1.不可能完全测试一个程序
2。不可能测试到程序对每一个输入的响应
3.不可能测试到程序的每一条可能的测试路径
4.无法找出所有设计错误

#	在测试过程中需思考问题：
(1)	测试的目的
(2)	测试优劣区别
(3)	做多少测试算足够了
(4)	怎么才能说，何时测试已经足够了

##测试分为：
#静态测试和动态测试
#白盒测试和黑盒测试
#随机测试和穷举测试
#自动测试和人工测试

测试步骤：
单元测试，集成测试，系统测试，回归测试，验收测试等。

#其他测试：
# BVT (Build Verification Test)，BVT是在所有开发工程师都已经检入自己的代码，项目组编译生成当天的版本之后进行，
主要目的是验证最新生成的软件版本在功能上是否完整，主要的软件特性是否正确。如无大的问题，就可以进行相应的功能测试。
BVT优点是时间短，验证了软件的基本功能。缺点是该种测试的覆盖率很低。因为运行时间短，不可能把所有的情况都测试到。
# Scenario Tests（基于用户实际应用场景的测试），在做BVT、功能测试的时候，可能测试主要集中在某个模块，或比较分离的功能上。
当用户来使用这个应用程序的时候，各个模块是作为一个整体来使用的，，那么在做测试的时候，就需要模仿用户这样一个真实的使用环境，
即用户会有哪些用法，会用这个应用程序做哪些事情，操作会是一个怎样的流程。加了这些测试用例后，再与BVT、功能测试配合，就能使软件整体都能符合用户使用的要求。
Scenario Tests优点是关注了用户的需求，缺点是有时候难以真正模仿用户真实的使用情况。
Smoke Test，在测试中发现问题，找到了一个Bug，然后开发人员会来修复这个Bug。
这时想知道这次修复是否真的解决了程序的Bug，或者是否会对其它模块造成影响，就需要针对此问题进行专门测试，这个过程就被称为Smoke Test。
在很多情况下，做Smoke Test是开发人员在试图解决一个问题的时候，造成了其它功能模块一系列的连锁反应，原因可能是只集中考虑了一开始的那个问题，
而忽略其它的问题，这就可能引起了新的Bug。Smoke Test优点是节省测试时间，防止build失败。缺点是覆盖率还是比较低。
此外，Application Compatibility Test（兼容性测试），主要目的是为了兼容第三方软件，
确保第三方软件能正常运行，用户不受影响。Accessibility Test（软件适用性测试），是确保软件对于某些有残疾的人士也能正常的使用，
但优先级比较低。其它的测试还有Functional Test（功能测试）、Security Test（安全性测试）、Stress Test（压力测试）、
Performance Test（性能测试）、Regression Test（回归测试）、Setup/Upgrade Test（安装升级测试）等。

静态测试：
静态测试包括代码检查、静态结构分析、代码质量度量等。

静态结构分析 静态结构分析主要是以图形的方式表现程序的内部结构，例如函数调用关系图、函数内部控制流图。
其中，函数调用关系图以直观的图形方式描述一个应用程序中各个函数的调用和被调用关系；控制流图显示一个函数的逻辑结构，
它由许多节点组成，一个节点代表一条语句或数条语句，连接结点的叫边，边表示节点间的控制流向。

#静态测试要点
(1)	同一程序内的代码书写是否为同一风格
(2)	代码布局是否合理、美观
(3)	程序中函数、子程序块分界是否明显
(4)	注释是否符合既定格式
(5)	注释是否正确反映代码的功能
(6)	变量定义是否正确（长度、类型、存储类型） 
(7)	是否引用了未初始化变量
(8)	数组和字符串的下标是否为整数
(9)	的数组和字符串的下标是否在范围内（不”越界”）
(10)	进行数组的检索及其它操作中，是否会出现”漏掉一个这种情况”
(11)	是否在应该使用常量的地方使用了变量（例：数组范围检查）
(12)	是否为变量赋予不同类型的值的情况下，赋值是否符合数据类型的转换规则
(13)	变量的命名是否相似
(14)	是否存在声明过，但从未引用或者只引用过一次的变量
(15)	在特定模块中所有的变量是否都显式声明过
(16)	非（15）的情况下，是否可以理解为该变量具有更高的共享级别
(17)	是否为引用的指针分配内存
(18)	数据结构在函数和子程序中的引用是否明确定义了其结构
(19)	计算中是否使用了不同数据类型的变量
(20)	计算中是否使用了不同的数据类型相同但长度不同的变量
(21)	赋值的目的变量是否小于赋值表达式的值
(22)	数值计算是否会出现溢出（向上）的情况
(23)	数值计算是否会出现溢出（向下）的情况
(24)	除数是否可能为零
(25)	某些计算是否会丢失计算精度
(26)	变量的值是否超过有意义的值
(27)	计算式的求值的顺序是否容易让人感到混乱
(28)	比较是否正确
(29)	是否存在分数和浮点数的比较
(30)	如果（29），精度问题是否会影响比较
(31)	每一个逻辑表达式是否都得到了正确表达
(32)	逻辑表达式的操作数是否均为逻辑值
(33)	程序中的Begin…End和Do…While等语句中，End是否对应
(34)	程序、模块、子程序和循环是否能够终止
(35)	是否存在永不执行的循环
(36)	是否存在多循环一次或少循环一次的情况
(37)	循环变量是否在循环内被错误地修改
(38)	多分支选择中，索引变量是否能超过可能的分支数
(39)	如果（38），该情况是否能够得到正确处理
(40)	子程序接受的参数类型、大小、次序是否和调用模块相匹配
(41)	全局变量定义和用法在各个模块中是否一致
(42)	是否修改了只作为输入用的参数
(43)	常量是否被做为形式参数进行传递

#动态测试概念
动态测试包括功能测试与接口测试、覆盖率分析、性能分析、内存分析等。 
功能与接口测试： 这部分的测试包括各个单元功能的正确执行、单元间的接口，
包括：单元接口、局部数据结构、重要的执行路径、错误处理的路径和影响上述几点的边界条件等内容。 
覆盖率分析： 覆盖率分析主要对代码的执行路径覆盖范围进行评估，语句覆盖、判定覆盖、条件覆盖、条件/判定覆盖、修正条件/判定覆盖、
基本路径覆盖都是从不同要求出发，为设计测试用例提出依据的。 
性能分析： 代码运行缓慢是开发过程中一个重要问题。一个应用程序运行速度较慢，程序员不容易找到是在哪里出现了问题?
如果不能解决应用程序的性能问题，将降低并极大地影响应用程序的质量，于是查找和修改性能瓶颈成为调整整个代码性能的关键。
目前性能分析工具大致分为纯软件的测试工具、纯硬件的测试工具（如逻辑分析仪和仿真器等）和软硬件结合的测试工具三类。 
内存分析： 内存泄漏会导致系统运行的崩溃，尤其对于嵌入式系统这种资源比较匮乏、应用非常广泛，而且往往又处于重要部位的，
将可能导致无法预料的重大损失。通过测量内存使用情况，我们可以了解程序内存分配的真实情况，发现对内存的不正常使用，在问题出现前发现征兆，
在系统崩溃前发现内存泄露错误；发现内存分配错误，并精确显示发生错误时的上下文情况，指出发生错误的原由。 
连接方式：　在嵌入式软件测试中，测试系统Host与被测试系统Target的连接有两种方式：直接连接和通过仿真器连接。直接连接是Host与Target通过串口、并口或网口直接连接。


#动态测试要点
(1)	测试数据是否具有一定的代表性
(2)	测试数据是否包含测试所用的各个等价类（边界条件、次边界条件、空白、无效）
(3)	是否可能从客户那边得到测试数据
(4)	非（3）的情况下，所用的测试数据是否具有实际的意义
(5)	是否每一组测试数据都得到了执行
(6)	每一组测试数据的测试结果是否与预期结果一致
(7)	文件的属性是否正确
(8)	打开文件语句是否正确
(9)	输入/输出语句是否与格式说明书所记述的一致
(10)	缓冲区大小与记录长度是否匹配
(11)	使用文件前是否已打开了文件
(12)	文件结束条件是否存在
(13)	产生输入/输出错误时，系统是否进行检测并处理
(14)	输出信息中是否存在文字书写错误和语法错误
(15)	控件尺寸是否大小适宜
(16)	控件颜色是否符合规约
(17)	控件布局是否合理、美观
(18)	控件TAB顺序是否从左到右，从上到下
(19)	数字输入框是否接受数字输入
(20)	在（19）的情况下、数字是否按既定格式显示
(21)	数字输入框是否拒绝字符串和”非法”数字的输入
(22)	组合框是否的能够进行下拉选择
(23)	组合框是否能够进行下拉多项选择
(24)	对于可添加数据组合框，添加数据后数据是否能够得到正确显示和进行选择
(25)	列表框是否能够进行选择
(26)	多项列表框是否能够进行多数据项选择
(27)	日期输入框是否接受正确的日期输入
(28)	日期输入框是否拒绝错误的日期输入
(29)	日期输入框在日期输入后是否按既定的日期格式显示日期
(30)	单选组内是否有且只有一个单选钮可选
(31)	如果单选组内无单选钮可选，这种情况是否允许存在
(32)	复选框组内是否允许多个复选框（包括全部可选）可选
(33)	如果复选框组内无复选框可选，这种情况是否允许存在
(34)	文本框及某些控件拒绝输入和选择时显示区域是否变灰或按既定规约处理
(35)	密码输入框是否按掩码的方式显示
(36)	Cancel之类的按钮按下后，控件中的数据是否清空复原或按既定规约处理
(37)	Submit之类的按钮按下后，数据是否得到提交或按既定规约处理
(38)	异常信息表述是否正确
(39)	软件是否按预期方式处理错误
(40)	文件或外设不存在的情况下是否存在相应的错误处理
(41)	软件是否严格的遵循外设的读写格式
(42)	画面文字（全、半角、格式、拼写）是否正确
(43)	产生的文件和数据表的格式是否正确
(44)	产生的文件和数据表的计算结果是否正确
(45)	打印的报表是否符合既定的格式
(46)	错误日志的表述是否正确
(47)	错误日志的格式是否正确

##回归测试的过程   
(1)	识别出软件中被修改的部分；
(2)	从原基线测试用例库T中，排除所有不再适用的测试用例，确定那些对新的软件版本依然有效的测试用例，其结果是建立一个新的基线测试用例库T0。
(3)	依据一定的策略从T0中选择测试用例测试被修改的软件。
(4)	如果必要，生成新的测试用例集T1，用于测试T0无法充分测试的软件部分。
(5)	用T1执行修改后的软件。
第(2)和第(3)步测试验证修改是否破坏了现有的功能，第(4)和第(5)步测试验证 修改工作本身。

